From f0f711936283956a95b960f916fbd5dd6377a2b5 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Michael=20M=C3=BCller?= <michael@fds-team.de>
Date: Sat, 31 Aug 2013 07:03:23 +0200
Subject: quartz: Implement IVMRMonitorConfig interface with stubs

---
 dlls/quartz/vmr9.c |  209 ++++++++++++++++++++++++++++++++++++++++++++++++++++
 1 file changed, 209 insertions(+)

diff --git a/dlls/quartz/vmr9.c b/dlls/quartz/vmr9.c
index 5a837dd..095ea50 100644
--- a/dlls/quartz/vmr9.c
+++ b/dlls/quartz/vmr9.c
@@ -170,7 +170,19 @@ static inline VMR9DefaultAllocatorPresenterImpl *impl_from_IVMRSurfaceAllocatorE
     return CONTAINING_RECORD(iface, VMR9DefaultAllocatorPresenterImpl, IVMRSurfaceAllocatorEx9_iface);
 }
 
+typedef struct
+{
+    IVMRMonitorConfig IVMRMonitorConfig_iface;
+    LONG refCount;
+} IVMRMonitorConfigImpl;
+
+static inline IVMRMonitorConfigImpl *impl_from_IVMRMonitorConfig( IVMRMonitorConfig *iface)
+{
+    return CONTAINING_RECORD(iface, IVMRMonitorConfigImpl, IVMRMonitorConfig_iface);
+}
+
 static HRESULT VMR9DefaultAllocatorPresenterImpl_create(VMR9Impl *parent, LPVOID * ppv);
+static HRESULT IVMRMonitorConfigImpl_create(LPVOID * ppv);
 
 static DWORD VMR9_SendSampleData(VMR9Impl *This, VMR9PresentationInfo *info, LPBYTE data, DWORD size)
 {
@@ -762,6 +774,13 @@ static HRESULT WINAPI VMR9Inner_QueryInterface(IUnknown * iface, REFIID riid, LP
         FIXME("No interface for IID_IVMRMixerBitmap9\n");
     else if (IsEqualIID(riid, &IID_IVMRMonitorConfig9))
         FIXME("No interface for IID_IVMRMonitorConfig9\n");
+    else if (IsEqualIID(riid, &IID_IVMRMonitorConfig))
+    {
+        HRESULT hr;
+        hr = IVMRMonitorConfigImpl_create(ppv);
+        if (SUCCEEDED(hr))
+            return hr;
+    }
     else if (IsEqualIID(riid, &IID_IVMRMixerControl9))
         FIXME("No interface for IID_IVMRMixerControl9\n");
     else
@@ -2239,6 +2258,196 @@ static const IVMRSurfaceAllocatorEx9Vtbl VMR9_SurfaceAllocator =
     NULL /* This isn't the SurfaceAllocatorEx type yet, working on it */
 };
 
+
+static HRESULT WINAPI VMR7_IVMRMonitorConfig_QueryInterface(IVMRMonitorConfig *iface, REFIID riid, LPVOID *ppv)
+{
+    IVMRMonitorConfigImpl *This = impl_from_IVMRMonitorConfig(iface);
+    TRACE("(%p/%p)->(%s, %p)\n", This, iface, qzdebugstr_guid(riid), ppv);
+
+    *ppv = NULL;
+
+    if (IsEqualIID(riid, &IID_IUnknown))
+        *ppv = (LPVOID)&(This->IVMRMonitorConfig_iface);
+    else if (IsEqualIID(riid, &IID_IVMRMonitorConfig))
+        *ppv = &This->IVMRMonitorConfig_iface;
+
+    if (*ppv)
+    {
+        IUnknown_AddRef((IUnknown *)(*ppv));
+        return S_OK;
+    }
+
+    FIXME("No interface for %s\n", debugstr_guid(riid));
+
+    return E_NOINTERFACE;
+}
+
+static ULONG WINAPI VMR7_IVMRMonitorConfig_AddRef(IVMRMonitorConfig *iface)
+{
+    IVMRMonitorConfigImpl *This = impl_from_IVMRMonitorConfig(iface);
+    ULONG refCount = InterlockedIncrement(&This->refCount);
+
+    TRACE("(%p)->() AddRef from %d\n", iface, refCount - 1);
+    return refCount;
+}
+
+static ULONG WINAPI VMR7_IVMRMonitorConfig_Release(IVMRMonitorConfig *iface)
+{
+    IVMRMonitorConfigImpl *This = impl_from_IVMRMonitorConfig(iface);
+    ULONG refCount = InterlockedDecrement(&This->refCount);
+
+    TRACE("(%p)->() Release from %d\n", iface, refCount + 1);
+
+    if (!refCount)
+    {
+        TRACE("Destroying\n");
+        CoTaskMemFree(This);
+        return 0;
+    }
+    return refCount;
+}
+
+static HRESULT WINAPI VMR7_IVMRMonitorConfig_SetMonitor(IVMRMonitorConfig *iface, const VMRGUID *pGUID)
+{
+    IVMRMonitorConfigImpl *This = impl_from_IVMRMonitorConfig(iface);
+
+    FIXME("(%p/%p)->(...) stub\n", iface, This);
+    return S_OK;
+}
+
+static HRESULT WINAPI VMR7_IVMRMonitorConfig_GetMonitor(IVMRMonitorConfig *iface, VMRGUID *pGUID)
+{
+    IVMRMonitorConfigImpl *This = impl_from_IVMRMonitorConfig(iface);
+
+    FIXME("(%p/%p)->(...) stub\n", iface, This);
+
+    if (pGUID)
+        pGUID->pGUID = NULL;
+
+    return S_OK;
+}
+
+
+static HRESULT WINAPI VMR7_IVMRMonitorConfig_SetDefaultMonitor(IVMRMonitorConfig *iface, const VMRGUID *pGUID)
+{
+    IVMRMonitorConfigImpl *This = impl_from_IVMRMonitorConfig(iface);
+
+    FIXME("(%p/%p)->(...) stub\n", iface, This);
+    return S_OK;
+}
+
+static HRESULT WINAPI VMR7_IVMRMonitorConfig_GetDefaultMonitor(IVMRMonitorConfig *iface, VMRGUID *pGUID)
+{
+    IVMRMonitorConfigImpl *This = impl_from_IVMRMonitorConfig(iface);
+
+    FIXME("(%p/%p)->(...) stub\n", iface, This);
+
+    if (pGUID)
+        pGUID->pGUID = NULL;
+
+    return S_OK;
+}
+
+static HRESULT WINAPI VMR7_IVMRMonitorConfig_GetAvailableMonitors(IVMRMonitorConfig *iface, VMRMONITORINFO *pinfo, DWORD dwMaxInfoArraySize, DWORD *pdwNumDevices)
+{
+    IVMRMonitorConfigImpl *This = impl_from_IVMRMonitorConfig(iface);
+    DISPLAY_DEVICEW device;
+    DWORD iDevNum;
+    DWORD count;
+    DEVMODEW mode;
+
+    /* FIXME: What is the correct behaviour if the array is too small? */
+    /* FIXME: Return monitor handle */
+    FIXME("(%p/%p)->(...) stub\n", iface, This);
+
+    if (!pdwNumDevices)
+        return E_POINTER;
+
+    device.cb = sizeof(DISPLAY_DEVICEW);
+
+    /* return the number of available monitors if pinfo == NULL */
+    if (pinfo == NULL)
+    {
+        iDevNum = 0;
+
+        while (EnumDisplayDevicesW(NULL, iDevNum++, &device, 0));
+
+        *pdwNumDevices = iDevNum;
+        return S_OK;
+    }
+
+    /* at least one entry */
+    if (dwMaxInfoArraySize == 0)
+        return E_INVALIDARG;
+
+    count   = 0;
+    iDevNum = 0;
+
+    while (count < dwMaxInfoArraySize && EnumDisplayDevicesW(NULL, iDevNum++, &device, 0))
+    {
+        mode.dmSize         = sizeof(DEVMODEW);
+        mode.dmDriverExtra  = 0;
+
+        if (!EnumDisplaySettingsExW(device.DeviceName, ENUM_CURRENT_SETTINGS, &mode, EDS_RAWMODE))
+            continue;
+
+        memset(pinfo, 0, sizeof(VMRMONITORINFO));
+
+        pinfo->guid.pGUID           = NULL; /* default DirectDraw device */
+
+        pinfo->rcMonitor.left       = mode.u1.s2.dmPosition.x;
+        pinfo->rcMonitor.top        = mode.u1.s2.dmPosition.y;
+        pinfo->rcMonitor.right      = mode.u1.s2.dmPosition.x + mode.dmPelsWidth;
+        pinfo->rcMonitor.bottom     = mode.u1.s2.dmPosition.y + mode.dmPelsHeight;
+
+        pinfo->hMon                 = 0;
+        pinfo->dwFlags              = (device.StateFlags & DISPLAY_DEVICE_PRIMARY_DEVICE) ? MONITORINFOF_PRIMARY : 9;
+
+        /* VMRDEVICENAMELEN == 32, sizeof(device.DeviceName) == 32 */
+        memcpy(&pinfo->szDevice,      device.DeviceName,   sizeof(device.DeviceName));
+        pinfo->szDevice[sizeof(device.DeviceName)/sizeof(WCHAR) - 1] = 0;
+
+        /* VMRDEVICEDESCRIPTIONLEN == 256, sizeof(device.DeviceString) == 128 */
+        memcpy(&pinfo->szDescription, device.DeviceString, sizeof(device.DeviceString));
+        /* remaining space is already zero */
+
+        count++;
+        pinfo++;
+    }
+
+    *pdwNumDevices = count;
+    return S_OK;
+}
+
+static const IVMRMonitorConfigVtbl VMR7_IVMRMonitorConfig_Vtbl =
+{
+    VMR7_IVMRMonitorConfig_QueryInterface,
+    VMR7_IVMRMonitorConfig_AddRef,
+    VMR7_IVMRMonitorConfig_Release,
+    VMR7_IVMRMonitorConfig_SetMonitor,
+    VMR7_IVMRMonitorConfig_GetMonitor,
+    VMR7_IVMRMonitorConfig_SetDefaultMonitor,
+    VMR7_IVMRMonitorConfig_GetDefaultMonitor,
+    VMR7_IVMRMonitorConfig_GetAvailableMonitors
+};
+
+static HRESULT IVMRMonitorConfigImpl_create(LPVOID *ppv)
+{
+    IVMRMonitorConfigImpl* This;
+
+    This = CoTaskMemAlloc(sizeof(IVMRMonitorConfigImpl));
+    if (!This)
+        return E_OUTOFMEMORY;
+
+    This->IVMRMonitorConfig_iface.lpVtbl = &VMR7_IVMRMonitorConfig_Vtbl;
+
+    This->refCount = 1;
+
+    *ppv = This;
+    return S_OK;
+}
+
+
 static IDirect3D9 *init_d3d9(HMODULE d3d9_handle)
 {
     IDirect3D9 * (__stdcall * d3d9_create)(UINT SDKVersion);
-- 
1.7.9.5

